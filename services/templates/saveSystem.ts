/**
 * DREAM3DFORGE - Save/Load System Template
 * 
 * This file provides a complete save/load system that can be embedded in generated games.
 * Includes TypeScript interfaces, implementation templates, and genre-specific schemas.
 */

// ============================================================================
// TYPE INTERFACES
// ============================================================================

export interface SaveData {
  /** Version of the save format for migration handling */
  version: string;
  /** Timestamp when the save was created */
  timestamp: number;
  /** Game identifier */
  gameId: string;
  /** Actual game state data */
  state: Record<string, any>;
  /** Checksum for corruption detection */
  checksum: string;
}

export interface SaveSlot {
  /** Unique identifier for the save slot */
  id: string;
  /** Display name */
  name: string;
  /** When the save was created */
  createdAt: number;
  /** When the save was last modified */
  modifiedAt: number;
  /** Playtime in seconds */
  playtime: number;
  /** Thumbnail data URL (optional) */
  thumbnail?: string;
  /** User-provided metadata */
  metadata: SaveMetadata;
  /** The actual save data */
  data: SaveData;
}

export interface SaveMetadata {
  /** Custom name given by player */
  customName?: string;
  /** Current level/stage */
  level?: string;
  /** Current score or progress metric */
  progress?: number;
  /** Difficulty setting */
  difficulty?: string;
  /** Additional custom fields */
  [key: string]: any;
}

export interface SaveSystemConfig {
  /** Game identifier */
  gameId: string;
  /** Save format version */
  version: string;
  /** Maximum number of save slots */
  maxSlots: number;
  /** Autosave interval in milliseconds (0 to disable) */
  autoSaveInterval: number;
  /** Enable compression for save data */
  compress: boolean;
  /** Storage backend: 'localStorage' | 'indexedDB' | 'memory' */
  storageBackend: 'localStorage' | 'indexedDB' | 'memory';
  /** Prefix for storage keys */
  storagePrefix: string;
  /** Enable save corruption detection */
  enableChecksum: boolean;
  /** Maximum save size in bytes (for localStorage) */
  maxSaveSize: number;
  /** Callback when autosave triggers */
  onAutoSave?: () => void;
  /** Callback when save operation fails */
  onSaveError?: (error: Error) => void;
  /** Callback when save is corrupted */
  onCorruptionDetected?: (slotId: string) => void;
}

export interface SaveSchema {
  /** Schema version */
  version: string;
  /** Game genre */
  genre: string;
  /** Required fields */
  required: string[];
  /** Field definitions */
  fields: Record<string, {
    type: 'string' | 'number' | 'boolean' | 'array' | 'object';
    default: any;
    description: string;
  }>;
  /** Migration handlers for older versions */
  migrations: Record<string, (data: any) => any>;
}

// ============================================================================
// SAVE SYSTEM IMPLEMENTATION (Injectable Code)
// ============================================================================

const SAVE_SYSTEM_IMPLEMENTATION = `
/**
 * SaveSystem - Complete save/load functionality for games
 * Auto-generated by DREAM3DFORGE
 */

class SaveSystem {
  private config: SaveSystemConfig;
  private autoSaveTimer: number | null = null;
  private currentState: Record<string, any> = {};
  private stateGetter: (() => Record<string, any>) | null = null;
  private stateSetter: ((state: Record<string, any>) => void) | null = null;
  private db: IDBDatabase | null = null;
  private initialized: boolean = false;

  constructor(config: Partial<SaveSystemConfig> = {}) {
    this.config = {
      gameId: config.gameId || 'game',
      version: config.version || '1.0.0',
      maxSlots: config.maxSlots || 10,
      autoSaveInterval: config.autoSaveInterval || 0,
      compress: config.compress !== false,
      storageBackend: config.storageBackend || 'localStorage',
      storagePrefix: config.storagePrefix || 'dream3dforge_save_',
      enableChecksum: config.enableChecksum !== false,
      maxSaveSize: config.maxSaveSize || 5 * 1024 * 1024,
      ...config
    };
  }

  async init(): Promise<void> {
    if (this.initialized) return;

    if (this.config.storageBackend === 'indexedDB') {
      await this.initIndexedDB();
    }

    this.initialized = true;

    // Start autosave if configured
    if (this.config.autoSaveInterval > 0) {
      this.startAutoSave();
    }

    console.log('[SaveSystem] Initialized with config:', this.config);
  }

  private async initIndexedDB(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.config.storagePrefix + 'db', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains('saves')) {
          db.createObjectStore('saves', { keyPath: 'id' });
        }
      };
    });
  }

  bindState(getter: () => Record<string, any>, setter: (state: Record<string, any>) => void): void {
    this.stateGetter = getter;
    this.stateSetter = setter;
  }

  private getState(): Record<string, any> {
    if (this.stateGetter) {
      return this.stateGetter();
    }
    return this.currentState;
  }

  private setState(state: Record<string, any>): void {
    if (this.stateSetter) {
      this.stateSetter(state);
    } else {
      this.currentState = state;
    }
  }

  async save(slotId?: string, metadata: Partial<SaveMetadata> = {}): Promise<string> {
    await this.init();

    const id = slotId || this.generateSlotId();
    const state = this.getState();
    const timestamp = Date.now();

    const saveData: SaveData = {
      version: this.config.version,
      timestamp,
      gameId: this.config.gameId,
      state: { ...state },
      checksum: this.config.enableChecksum ? this.calculateChecksum(state) : ''
    };

    const slot: SaveSlot = {
      id,
      name: metadata.customName || \`Save \${new Date().toLocaleString()}\`,
      createdAt: timestamp,
      modifiedAt: timestamp,
      playtime: metadata.playtime || 0,
      thumbnail: metadata.thumbnail,
      metadata: metadata as SaveMetadata,
      data: saveData
    };

    try {
      const serialized = JSON.stringify(slot);
      const dataToStore = this.config.compress ? this.compress(serialized) : serialized;

      if (this.config.storageBackend === 'indexedDB' && this.db) {
        await this.saveToIndexedDB(slot);
      } else if (this.config.storageBackend === 'localStorage') {
        this.saveToLocalStorage(id, dataToStore);
      } else {
        this.saveToMemory(id, slot);
      }

      console.log('[SaveSystem] Saved to slot:', id);
      return id;
    } catch (error) {
      console.error('[SaveSystem] Save failed:', error);
      this.config.onSaveError?.(error as Error);
      throw error;
    }
  }

  private async saveToIndexedDB(slot: SaveSlot): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('IndexedDB not initialized'));
      
      const transaction = this.db.transaction(['saves'], 'readwrite');
      const store = transaction.objectStore('saves');
      const request = store.put(slot);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  private saveToLocalStorage(id: string, data: string): void {
    const key = this.config.storagePrefix + id;
    if (data.length > this.config.maxSaveSize) {
      throw new Error('Save data exceeds maximum size for localStorage');
    }
    localStorage.setItem(key, data);
  }

  private memoryStore: Map<string, SaveSlot> = new Map();

  private saveToMemory(id: string, slot: SaveSlot): void {
    this.memoryStore.set(id, slot);
  }

  async load(slotId: string): Promise<Record<string, any>> {
    await this.init();

    const slot = await this.getSlot(slotId);
    if (!slot) {
      throw new Error(\`Save slot not found: \${slotId}\`);
    }

    // Verify checksum
    if (this.config.enableChecksum && slot.data.checksum) {
      const currentChecksum = this.calculateChecksum(slot.data.state);
      if (currentChecksum !== slot.data.checksum) {
        console.error('[SaveSystem] Save corruption detected!');
        this.config.onCorruptionDetected?.(slotId);
        throw new Error('Save data appears to be corrupted');
      }
    }

    // Check version compatibility
    if (slot.data.version !== this.config.version) {
      console.warn('[SaveSystem] Version mismatch:', slot.data.version, '!==', this.config.version);
      // Could trigger migration here
    }

    this.setState(slot.data.state);
    console.log('[SaveSystem] Loaded from slot:', slotId);
    return slot.data.state;
  }

  async getSlot(slotId: string): Promise<SaveSlot | null> {
    if (this.config.storageBackend === 'indexedDB' && this.db) {
      return this.loadFromIndexedDB(slotId);
    } else if (this.config.storageBackend === 'localStorage') {
      return this.loadFromLocalStorage(slotId);
    } else {
      return this.memoryStore.get(slotId) || null;
    }
  }

  private async loadFromIndexedDB(slotId: string): Promise<SaveSlot | null> {
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('IndexedDB not initialized'));
      
      const transaction = this.db.transaction(['saves'], 'readonly');
      const store = transaction.objectStore('saves');
      const request = store.get(slotId);
      
      request.onsuccess = () => resolve(request.result || null);
      request.onerror = () => reject(request.error);
    });
  }

  private loadFromLocalStorage(slotId: string): SaveSlot | null {
    const key = this.config.storagePrefix + slotId;
    const data = localStorage.getItem(key);
    if (!data) return null;

    try {
      const decompressed = this.config.compress ? this.decompress(data) : data;
      return JSON.parse(decompressed);
    } catch (error) {
      console.error('[SaveSystem] Failed to parse save data:', error);
      return null;
    }
  }

  async listSaves(): Promise<SaveSlot[]> {
    await this.init();

    const saves: SaveSlot[] = [];

    if (this.config.storageBackend === 'indexedDB' && this.db) {
      saves.push(...await this.listIndexedDBSaves());
    } else if (this.config.storageBackend === 'localStorage') {
      saves.push(...this.listLocalStorageSaves());
    } else {
      saves.push(...Array.from(this.memoryStore.values()));
    }

    return saves.sort((a, b) => b.modifiedAt - a.modifiedAt);
  }

  private async listIndexedDBSaves(): Promise<SaveSlot[]> {
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('IndexedDB not initialized'));
      
      const transaction = this.db.transaction(['saves'], 'readonly');
      const store = transaction.objectStore('saves');
      const request = store.getAll();
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  private listLocalStorageSaves(): SaveSlot[] {
    const saves: SaveSlot[] = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith(this.config.storagePrefix)) {
        const slotId = key.slice(this.config.storagePrefix.length);
        const slot = this.loadFromLocalStorage(slotId);
        if (slot) saves.push(slot);
      }
    }
    return saves;
  }

  async delete(slotId: string): Promise<boolean> {
    await this.init();

    try {
      if (this.config.storageBackend === 'indexedDB' && this.db) {
        await this.deleteFromIndexedDB(slotId);
      } else if (this.config.storageBackend === 'localStorage') {
        localStorage.removeItem(this.config.storagePrefix + slotId);
      } else {
        this.memoryStore.delete(slotId);
      }

      console.log('[SaveSystem] Deleted slot:', slotId);
      return true;
    } catch (error) {
      console.error('[SaveSystem] Delete failed:', error);
      return false;
    }
  }

  private async deleteFromIndexedDB(slotId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.db) return reject(new Error('IndexedDB not initialized'));
      
      const transaction = this.db.transaction(['saves'], 'readwrite');
      const store = transaction.objectStore('saves');
      const request = store.delete(slotId);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  export(): string {
    const state = this.getState();
    const saveData: SaveData = {
      version: this.config.version,
      timestamp: Date.now(),
      gameId: this.config.gameId,
      state,
      checksum: this.config.enableChecksum ? this.calculateChecksum(state) : ''
    };

    const json = JSON.stringify(saveData);
    const compressed = this.compress(json);
    return btoa(compressed);
  }

  async import(base64: string): Promise<boolean> {
    try {
      const compressed = atob(base64);
      const json = this.decompress(compressed);
      const saveData: SaveData = JSON.parse(json);

      // Verify checksum
      if (this.config.enableChecksum && saveData.checksum) {
        const currentChecksum = this.calculateChecksum(saveData.state);
        if (currentChecksum !== saveData.checksum) {
          throw new Error('Imported save appears to be corrupted');
        }
      }

      this.setState(saveData.state);
      console.log('[SaveSystem] Imported save data');
      return true;
    } catch (error) {
      console.error('[SaveSystem] Import failed:', error);
      return false;
    }
  }

  startAutoSave(): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
    }

    if (this.config.autoSaveInterval > 0) {
      this.autoSaveTimer = window.setInterval(() => {
        this.save('autosave', { customName: 'Autosave' });
        this.config.onAutoSave?.();
      }, this.config.autoSaveInterval);

      console.log('[SaveSystem] Autosave started, interval:', this.config.autoSaveInterval);
    }
  }

  stopAutoSave(): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
      console.log('[SaveSystem] Autosave stopped');
    }
  }

  quickSave(): Promise<string> {
    return this.save('quicksave', { customName: 'Quicksave' });
  }

  async quickLoad(): Promise<Record<string, any>> {
    return this.load('quicksave');
  }

  private generateSlotId(): string {
    return 'save_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  private calculateChecksum(data: any): string {
    const str = JSON.stringify(data);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(16);
  }

  // Simple LZ-string style compression
  private compress(input: string): string {
    // If input is small, don't compress
    if (input.length < 100) return '0' + input;

    const dict: Map<string, number> = new Map();
    const data: number[] = [];
    let dictSize = 256;

    for (let i = 0; i < 256; i++) {
      dict.set(String.fromCharCode(i), i);
    }

    let w = '';
    for (const c of input) {
      const wc = w + c;
      if (dict.has(wc)) {
        w = wc;
      } else {
        data.push(dict.get(w)!);
        if (dictSize < 65536) {
          dict.set(wc, dictSize++);
        }
        w = c;
      }
    }

    if (w !== '') {
      data.push(dict.get(w)!);
    }

    // Convert to base64-like string
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let result = '1'; // Prefix to indicate compression
    for (let i = 0; i < data.length; i += 3) {
      const b1 = data[i];
      const b2 = data[i + 1] || 0;
      const b3 = data[i + 2] || 0;
      
      result += chars[(b1 >> 2) & 63];
      result += chars[((b1 << 4) | (b2 >> 4)) & 63];
      result += chars[((b2 << 2) | (b3 >> 6)) & 63];
      result += chars[b3 & 63];
    }

    return result;
  }

  private decompress(input: string): string {
    if (input[0] === '0') return input.slice(1);

    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    const charMap: Map<string, number> = new Map();
    for (let i = 0; i < chars.length; i++) {
      charMap.set(chars[i], i);
    }

    const data: number[] = [];
    for (let i = 1; i < input.length; i += 4) {
      const c1 = charMap.get(input[i]) || 0;
      const c2 = charMap.get(input[i + 1]) || 0;
      const c3 = charMap.get(input[i + 2]) || 0;
      const c4 = charMap.get(input[i + 3]) || 0;
      
      data.push((c1 << 2) | (c2 >> 4));
      if (input[i + 2] !== '=') data.push(((c2 << 4) | (c3 >> 2)) & 255);
      if (input[i + 3] !== '=') data.push(((c3 << 6) | c4) & 255);
    }

    const dict: string[] = [];
    for (let i = 0; i < 256; i++) {
      dict.push(String.fromCharCode(i));
    }

    let result = '';
    let w = dict[data[0]];
    result += w;

    for (let i = 1; i < data.length; i++) {
      const k = data[i];
      let entry: string;
      
      if (k < dict.length) {
        entry = dict[k];
      } else if (k === dict.length) {
        entry = w + w[0];
      } else {
        throw new Error('Invalid compressed data');
      }

      result += entry;
      dict.push(w + entry[0]);
      w = entry;
    }

    return result;
  }

  getStorageUsage(): { used: number; total: number; percentage: number } {
    if (this.config.storageBackend !== 'localStorage') {
      return { used: 0, total: Infinity, percentage: 0 };
    }

    let used = 0;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith(this.config.storagePrefix)) {
        used += localStorage.getItem(key)!.length * 2; // UTF-16 = 2 bytes per char
      }
    }

    // Estimate localStorage limit (typically 5-10MB)
    const total = 5 * 1024 * 1024;
    return {
      used,
      total,
      percentage: Math.round((used / total) * 100)
    };
  }

  destroy(): void {
    this.stopAutoSave();
    if (this.db) {
      this.db.close();
      this.db = null;
    }
    this.initialized = false;
  }
}

// AutoSave helper class for more control
class AutoSave {
  private saveSystem: SaveSystem;
  private config: {
    interval: number;
    onSave: () => void;
    condition?: () => boolean;
  };
  private timer: number | null = null;

  constructor(saveSystem: SaveSystem, config: {
    interval: number;
    onSave?: () => void;
    condition?: () => boolean;
  }) {
    this.saveSystem = saveSystem;
    this.config = {
      interval: config.interval,
      onSave: config.onSave || (() => {}),
      condition: config.condition
    };
  }

  start(): void {
    if (this.timer) return;
    
    this.timer = window.setInterval(() => {
      if (!this.config.condition || this.config.condition()) {
        this.saveSystem.quickSave();
        this.config.onSave();
      }
    }, this.config.interval);
  }

  stop(): void {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }

  pause(): void {
    this.stop();
  }

  resume(): void {
    this.start();
  }
}
`;

// ============================================================================
// GENRE-SPECIFIC SAVE TEMPLATES
// ============================================================================

export const ARENA_SHOOTER_SAVE_TEMPLATE = `
// Arena Shooter Save Schema
const ARENA_SHOOTER_SCHEMA = {
  version: '1.0.0',
  genre: 'arena_shooter',
  required: ['score', 'wave', 'player'],
  fields: {
    // Core Progress
    score: { type: 'number', default: 0, description: 'Current score' },
    highScore: { type: 'number', default: 0, description: 'Best score achieved' },
    wave: { type: 'number', default: 1, description: 'Current wave number' },
    
    // Random Seed
    seed: { type: 'string', default: '', description: 'RNG seed for deterministic replay' },
    
    // Player State
    'player.health': { type: 'number', default: 100, description: 'Player health' },
    'player.maxHealth': { type: 'number', default: 100, description: 'Maximum health' },
    'player.position': { type: 'object', default: { x: 0, y: 0 }, description: 'Player position' },
    'player.weapon': { type: 'string', default: 'pistol', description: 'Current weapon' },
    
    // Upgrades
    'upgrades.damage': { type: 'number', default: 1, description: 'Damage multiplier' },
    'upgrades.fireRate': { type: 'number', default: 1, description: 'Fire rate multiplier' },
    'upgrades.speed': { type: 'number', default: 1, description: 'Movement speed multiplier' },
    'upgrades.healthRegen': { type: 'number', default: 0, description: 'Health regeneration' },
    
    // Session Stats
    kills: { type: 'number', default: 0, description: 'Total enemies killed' },
    shotsFired: { type: 'number', default: 0, description: 'Total shots fired' },
    accuracy: { type: 'number', default: 0, description: 'Hit accuracy percentage' },
    playtime: { type: 'number', default: 0, description: 'Session playtime in seconds' }
  },
  migrations: {}
};

// Default arena shooter save state
function createArenaShooterSaveState(): Record<string, any> {
  return {
    score: 0,
    highScore: 0,
    wave: 1,
    seed: Math.random().toString(36).substring(2, 15),
    player: {
      health: 100,
      maxHealth: 100,
      position: { x: 0, y: 0, z: 0 },
      weapon: 'pistol',
      ammo: { pistol: 999, shotgun: 50, rifle: 150 }
    },
    upgrades: {
      damage: 1,
      fireRate: 1,
      speed: 1,
      healthRegen: 0,
      multishot: 1,
      piercing: 0
    },
    enemies: [],
    powerups: [],
    kills: 0,
    shotsFired: 0,
    shotsHit: 0,
    accuracy: 0,
    playtime: 0
  };
}
`;

export const PLATFORMER_SAVE_TEMPLATE = `
// Platformer Save Schema
const PLATFORMER_SCHEMA = {
  version: '1.0.0',
  genre: 'platformer',
  required: ['level', 'position', 'deaths'],
  fields: {
    // Level Progress
    level: { type: 'string', default: '1-1', description: 'Current level identifier' },
    unlockedLevels: { type: 'array', default: ['1-1'], description: 'List of unlocked levels' },
    
    // Player State
    'position.x': { type: 'number', default: 0, description: 'Player X position' },
    'position.y': { type: 'number', default: 0, description: 'Player Y position' },
    'position.checkpoint': { type: 'string', default: '', description: 'Last checkpoint reached' },
    
    // Stats
    deaths: { type: 'number', default: 0, description: 'Total death count' },
    jumps: { type: 'number', default: 0, description: 'Total jumps performed' },
    playtime: { type: 'number', default: 0, description: 'Total playtime in seconds' },
    
    // Collectibles
    'collectibles.coins': { type: 'number', default: 0, description: 'Coins collected' },
    'collectibles.totalCoins': { type: 'number', default: 0, description: 'Total coins available' },
    'collectibles.secrets': { type: 'array', default: [], description: 'Discovered secrets' },
    
    // Abilities
    'abilities.doubleJump': { type: 'boolean', default: false, description: 'Double jump unlocked' },
    'abilities.wallJump': { type: 'boolean', default: false, description: 'Wall jump unlocked' },
    'abilities.dash': { type: 'boolean', default: false, description: 'Dash unlocked' },
    'abilities.glide': { type: 'boolean', default: false, description: 'Glide unlocked' },
    
    // Best Times
    bestTimes: { type: 'object', default: {}, description: 'Best completion times per level' }
  },
  migrations: {}
};

// Default platformer save state
function createPlatformerSaveState(): Record<string, any> {
  return {
    level: '1-1',
    unlockedLevels: ['1-1'],
    position: {
      x: 0,
      y: 0,
      checkpoint: ''
    },
    deaths: 0,
    jumps: 0,
    playtime: 0,
    collectibles: {
      coins: 0,
      totalCoins: 0,
      secrets: [],
      gems: [],
      relics: []
    },
    abilities: {
      doubleJump: false,
      wallJump: false,
      dash: false,
      glide: false,
      groundPound: false
    },
    bestTimes: {},
    flags: {
      introSeen: false,
      tutorialComplete: false
    }
  };
}
`;

export const RPG_SAVE_TEMPLATE = `
// RPG Save Schema
const RPG_SCHEMA = {
  version: '1.0.0',
  genre: 'rpg',
  required: ['player', 'inventory', 'quests'],
  fields: {
    // Player Stats
    'player.name': { type: 'string', default: 'Hero', description: 'Character name' },
    'player.level': { type: 'number', default: 1, description: 'Character level' },
    'player.xp': { type: 'number', default: 0, description: 'Experience points' },
    'player.xpToNext': { type: 'number', default: 100, description: 'XP needed for next level' },
    
    // Attributes
    'player.stats.strength': { type: 'number', default: 10, description: 'Strength stat' },
    'player.stats.dexterity': { type: 'number', default: 10, description: 'Dexterity stat' },
    'player.stats.intelligence': { type: 'number', default: 10, description: 'Intelligence stat' },
    'player.stats.vitality': { type: 'number', default: 10, description: 'Vitality stat' },
    
    // Resources
    'player.health': { type: 'number', default: 100, description: 'Current health' },
    'player.maxHealth': { type: 'number', default: 100, description: 'Maximum health' },
    'player.mana': { type: 'number', default: 50, description: 'Current mana' },
    'player.maxMana': { type: 'number', default: 50, description: 'Maximum mana' },
    'player.gold': { type: 'number', default: 0, description: 'Gold/currency' },
    
    // Progress
    'player.position': { type: 'object', default: { x: 0, y: 0, map: 'start' }, description: 'World position' },
    
    // Inventory
    'inventory.items': { type: 'array', default: [], description: 'Item list' },
    'inventory.equipped.weapon': { type: 'string', default: '', description: 'Equipped weapon' },
    'inventory.equipped.armor': { type: 'string', default: '', description: 'Equipped armor' },
    'inventory.equipped.accessories': { type: 'array', default: [], description: 'Equipped accessories' },
    
    // Quests
    'quests.active': { type: 'array', default: [], description: 'Active quests' },
    'quests.completed': { type: 'array', default: [], description: 'Completed quests' },
    'quests.failed': { type: 'array', default: [], description: 'Failed quests' },
    
    // World State
    worldFlags: { type: 'object', default: {}, description: 'Persistent world state flags' },
    npcStates: { type: 'object', default: {}, description: 'NPC interaction states' },
    discoveredAreas: { type: 'array', default: [], description: 'Discovered map areas' }
  },
  migrations: {}
};

// Default RPG save state
function createRPGSaveState(): Record<string, any> {
  return {
    player: {
      name: 'Hero',
      level: 1,
      xp: 0,
      xpToNext: 100,
      stats: {
        strength: 10,
        dexterity: 10,
        intelligence: 10,
        vitality: 10,
        luck: 10
      },
      health: 100,
      maxHealth: 100,
      mana: 50,
      maxMana: 50,
      stamina: 100,
      maxStamina: 100,
      gold: 0,
      position: {
        x: 0,
        y: 0,
        z: 0,
        map: 'village',
        spawnPoint: 'village_inn'
      },
      skillPoints: 0,
      skillTree: {}
    },
    inventory: {
      items: [],
      maxSlots: 20,
      equipped: {
        weapon: null,
        head: null,
        body: null,
        hands: null,
        legs: null,
        feet: null,
        ring1: null,
        ring2: null,
        necklace: null
      }
    },
    quests: {
      active: [],
      completed: [],
      failed: []
    },
    world: {
      flags: {},
      time: 0,
      day: 1,
      weather: 'clear'
    },
    npcs: {},
    enemiesDefeated: [],
    chestsOpened: [],
    discoveredAreas: ['village'],
    playtime: 0
  };
}
`;

export const ROGUELIKE_SAVE_TEMPLATE = `
// Roguelike Save Schema
const ROGUELIKE_SCHEMA = {
  version: '1.0.0',
  genre: 'roguelike',
  required: ['run', 'meta'],
  fields: {
    // Run State (ephemeral)
    'run.active': { type: 'boolean', default: false, description: 'Is run in progress' },
    'run.floor': { type: 'number', default: 1, description: 'Current floor/dungeon level' },
    'run.seed': { type: 'string', default: '', description: 'Run RNG seed' },
    'run.player.health': { type: 'number', default: 100, description: 'Current health' },
    'run.player.maxHealth': { type: 'number', default: 100, description: 'Max health' },
    'run.player.position': { type: 'object', default: { x: 0, y: 0 }, description: 'Position' },
    'run.player.gold': { type: 'number', default: 0, description: 'Run gold' },
    'run.inventory': { type: 'array', default: [], description: 'Current items' },
    'run.relics': { type: 'array', default: [], description: 'Collected relics' },
    'run.mapVisited': { type: 'object', default: {}, description: 'Explored map tiles' },
    'run.enemiesDefeated': { type: 'number', default: 0, description: 'Kills this run' },
    
    // Meta Progress (persistent)
    'meta.runsCompleted': { type: 'number', default: 0, description: 'Total completed runs' },
    'meta.runsAttempted': { type: 'number', default: 0, description: 'Total runs started' },
    'meta.bestFloor': { type: 'number', default: 0, description: 'Deepest floor reached' },
    'meta.totalKills': { type: 'number', default: 0, description: 'Total enemies killed' },
    'meta.currency.essence': { type: 'number', default: 0, description: 'Meta currency' },
    'meta.currency.soulShards': { type: 'number', default: 0, description: 'Rare meta currency' },
    
    // Unlocks
    'meta.unlocked.characters': { type: 'array', default: ['warrior'], description: 'Unlocked characters' },
    'meta.unlocked.relics': { type: 'array', default: [], description: 'Discovered relics' },
    'meta.unlocked.blessings': { type: 'array', default: [], description: 'Unlocked blessings' },
    'meta.unlocked.difficulties': { type: 'array', default: ['normal'], description: 'Unlocked difficulties' },
    
    // Upgrades
    'meta.upgrades.maxHealthBonus': { type: 'number', default: 0, description: 'Permanent health bonus' },
    'meta.upgrades.startingGoldBonus': { type: 'number', default: 0, description: 'Starting gold bonus' },
    'meta.upgrades.shopDiscount': { type: 'number', default: 0, description: 'Shop price reduction' },
    
    // Achievements
    achievements: { type: 'array', default: [], description: 'Earned achievements' },
    
    // Statistics
    'stats.totalPlaytime': { type: 'number', default: 0, description: 'Total playtime' },
    'stats.favoriteCharacter': { type: 'string', default: '', description: 'Most played character' }
  },
  migrations: {}
};

// Default roguelike save state
function createRoguelikeSaveState(): Record<string, any> {
  return {
    // Current Run (resets on death/quit)
    run: {
      active: false,
      character: 'warrior',
      floor: 1,
      seed: '',
      player: {
        health: 100,
        maxHealth: 100,
        position: { x: 0, y: 0 },
        gold: 0,
        blessings: [],
        curses: []
      },
      inventory: [],
      relics: [],
      potions: { small: 0, medium: 0, large: 0 },
      map: {
        visited: {},
        revealed: {},
        currentRoom: 'entrance'
      },
      enemiesDefeated: 0,
      roomsCleared: 0,
      elitesDefeated: 0,
      bossesDefeated: 0,
      runTime: 0
    },
    
    // Meta Progress (persists between runs)
    meta: {
      runsCompleted: 0,
      runsAttempted: 0,
      wins: 0,
      bestFloor: 0,
      bestTime: Infinity,
      totalKills: 0,
      totalGoldCollected: 0,
      currency: {
        essence: 0,
        soulShards: 0
      },
      unlocked: {
        characters: ['warrior'],
        relics: [],
        blessings: [],
        difficulties: ['normal'],
        alternateSkins: [],
        endings: []
      },
      upgrades: {
        maxHealthBonus: 0,
        startingGoldBonus: 0,
        shopDiscount: 0,
        potionEfficiency: 0,
        critChanceBonus: 0,
        dodgeChanceBonus: 0,
        extraLife: 0
      },
      characterStats: {
        warrior: { runs: 0, wins: 0, bestFloor: 0 },
        mage: { runs: 0, wins: 0, bestFloor: 0 },
        rogue: { runs: 0, wins: 0, bestFloor: 0 }
      }
    },
    
    achievements: [],
    stats: {
      totalPlaytime: 0,
      favoriteCharacter: '',
      favoriteRelic: '',
      mostKillsInRun: 0,
      fastestWin: Infinity
    },
    settings: {
      autoSaveRuns: true,
      saveOnExit: true
    }
  };
}
`;

export const STRATEGY_SAVE_TEMPLATE = `
// Strategy Save Schema
const STRATEGY_SCHEMA = {
  version: '1.0.0',
  genre: 'strategy',
  required: ['turn', 'resources', 'units'],
  fields: {
    // Game State
    turn: { type: 'number', default: 1, description: 'Current turn number' },
    phase: { type: 'string', default: 'planning', description: 'Current game phase' },
    difficulty: { type: 'string', default: 'normal', description: 'Game difficulty' },
    
    // Resources
    'resources.gold': { type: 'number', default: 100, description: 'Gold amount' },
    'resources.wood': { type: 'number', default: 50, description: 'Wood amount' },
    'resources.stone': { type: 'number', default: 30, description: 'Stone amount' },
    'resources.food': { type: 'number', default: 100, description: 'Food supply' },
    'resources.population': { type: 'number', default: 5, description: 'Current population' },
    'resources.popCap': { type: 'number', default: 10, description: 'Population capacity' },
    
    // Map
    'map.seed': { type: 'string', default: '', description: 'Map generation seed' },
    'map.size': { type: 'string', default: 'medium', description: 'Map size' },
    'map.terrain': { type: 'array', default: [], description: 'Terrain data' },
    'map.fogOfWar': { type: 'object', default: {}, description: 'Revealed areas' },
    'map.ownedTiles': { type: 'array', default: [], description: 'Controlled territory' },
    
    // Units
    units: { type: 'array', default: [], description: 'All units on map' },
    selectedUnit: { type: 'string', default: '', description: 'Currently selected unit ID' },
    
    // Buildings
    buildings: { type: 'array', default: [], description: 'Constructed buildings' },
    buildingQueue: { type: 'array', default: [], description: 'Build queue' },
    
    // Tech/Upgrades
    'tech.researched': { type: 'array', default: [], description: 'Unlocked technologies' },
    'tech.researching': { type: 'string', default: '', description: 'Current research' },
    'tech.progress': { type: 'number', default: 0, description: 'Research progress' },
    
    // Diplomacy
    'diplomacy.factions': { type: 'object', default: {}, description: 'Faction relations' },
    'diplomacy.treaties': { type: 'array', default: [], description: 'Active treaties' },
    'diplomacy.wars': { type: 'array', default: [], description: 'Active wars' },
    
    // AI State
    'ai.factions': { type: 'object', default: {}, description: 'AI faction states' }
  },
  migrations: {}
};

// Default strategy save state
function createStrategySaveState(): Record<string, any> {
  return {
    // Game State
    turn: 1,
    phase: 'planning', // planning, execution, combat, resolution
    subPhase: 'resource', // resource, production, movement, combat, building
    difficulty: 'normal',
    victoryCondition: 'conquest',
    gameTime: 0,
    
    // Player Resources
    resources: {
      gold: 100,
      wood: 50,
      stone: 30,
      iron: 0,
      food: 100,
      mana: 0,
      population: 5,
      popCap: 10,
      workers: 3,
      idleWorkers: 3
    },
    
    // Economy
    income: {
      gold: 0,
      wood: 0,
      stone: 0,
      food: 0
    },
    
    // Map
    map: {
      seed: Math.random().toString(36).substring(2, 15),
      size: { width: 32, height: 32 },
      tiles: [], // Generated from seed
      fogOfWar: {},
      revealedTiles: [],
      ownedTiles: [{ x: 0, y: 0 }],
      resourceNodes: [],
      villages: [],
      ruins: []
    },
    
    // Units
    units: [],
    selectedUnits: [],
    unitGroups: {},
    formations: {},
    
    // Buildings
    buildings: [],
    buildingQueue: [],
    maxQueueSize: 5,
    
    // Technology
    tech: {
      researched: ['basic_agriculture'],
      available: [],
      researching: null,
      progress: 0,
      researchRate: 10
    },
    
    // Factions/Diplomacy
    factions: {
      player: {
        name: 'Player',
        color: '#3498db',
        leader: 'Commander',
        attitude: 'player'
      }
    },
    relations: {},
    treaties: [],
    wars: [],
    tradeRoutes: [],
    
    // Events
    activeEvents: [],
    eventHistory: [],
    
    // Statistics
    stats: {
      unitsCreated: 0,
      unitsLost: 0,
      unitsKilled: 0,
      buildingsConstructed: 0,
      buildingsDestroyed: 0,
      resourcesGathered: {},
      battlesWon: 0,
      battlesLost: 0
    },
    
    // Victory Progress
    victoryProgress: {
      conquest: 0,
      domination: 0,
      economic: 0,
      scientific: 0,
      cultural: 0
    }
  };
}
`;

// ============================================================================
// UI COMPONENTS CODE
// ============================================================================

const SAVE_SYSTEM_UI_CODE = `
/**
 * Save System UI Components
 * Provides save slot selector, quick save/load, and corruption detection UI
 */

interface SaveSlotUIProps {
  saveSystem: SaveSystem;
  onLoad?: (slotId: string) => void;
  onDelete?: (slotId: string) => void;
  onExport?: (slotId: string) => void;
}

// Save Slot Selector Component
class SaveSlotSelector {
  private container: HTMLElement;
  private saveSystem: SaveSystem;
  private slots: SaveSlot[] = [];
  private callbacks: SaveSlotUIProps;

  constructor(containerId: string, props: SaveSlotUIProps) {
    this.container = document.getElementById(containerId)!;
    this.saveSystem = props.saveSystem;
    this.callbacks = props;
    this.render();
    this.refresh();
  }

  async refresh(): Promise<void> {
    this.slots = await this.saveSystem.listSaves();
    this.renderSlots();
  }

  private render(): void {
    this.container.innerHTML = \`
      <div class="save-slot-selector">
        <div class="save-header">
          <h3>Saved Games</h3>
          <div class="save-storage-info" id="storage-info"></div>
        </div>
        <div class="save-slots-grid" id="save-slots"></div>
        <div class="save-actions">
          <button id="btn-new-save" class="btn-primary">New Save</button>
          <button id="btn-import" class="btn-secondary">Import</button>
          <button id="btn-close" class="btn-close">×</button>
        </div>
        <input type="file" id="import-file" accept=".sav,.json" style="display:none">
      </div>
    \`;

    this.attachEventListeners();
  }

  private renderSlots(): void {
    const grid = this.container.querySelector('#save-slots')!;
    
    if (this.slots.length === 0) {
      grid.innerHTML = '<div class="no-saves">No saved games found</div>';
      return;
    }

    grid.innerHTML = this.slots.map(slot => \`
      <div class="save-slot" data-id="\${slot.id}">
        <div class="save-thumbnail">
          \${slot.thumbnail 
            ? \`<img src="\${slot.thumbnail}" alt="Save thumbnail">\`
            : \`<div class="save-placeholder">\${slot.metadata.level || '?'}</div>\`
          }
        </div>
        <div class="save-info">
          <div class="save-name">\${slot.metadata.customName || slot.name}</div>
          <div class="save-details">
            <span class="save-date">\${new Date(slot.modifiedAt).toLocaleDateString()}</span>
            <span class="save-time">\${this.formatPlaytime(slot.playtime)}</span>
          </div>
          <div class="save-meta">
            \${slot.metadata.difficulty ? \`<span class="badge">\${slot.metadata.difficulty}</span>\` : ''}
            \${slot.metadata.progress ? \`<span class="progress">\${slot.metadata.progress}%</span>\` : ''}
          </div>
        </div>
        <div class="save-actions-dropdown">
          <button class="btn-menu">⋮</button>
          <div class="dropdown-content">
            <button class="btn-load" data-id="\${slot.id}">Load</button>
            <button class="btn-export" data-id="\${slot.id}">Export</button>
            <button class="btn-delete" data-id="\${slot.id}">Delete</button>
          </div>
        </div>
      </div>
    \`).join('');

    // Update storage info
    const usage = this.saveSystem.getStorageUsage();
    const storageInfo = this.container.querySelector('#storage-info')!;
    storageInfo.innerHTML = \`Storage: \${(usage.used / 1024).toFixed(1)}KB / \${(usage.total / 1024).toFixed(0)}KB (\${usage.percentage}%)\`;

    this.attachSlotEventListeners();
  }

  private formatPlaytime(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    if (hours > 0) return \`\${hours}h \${mins}m\`;
    return \`\${mins}m\`;
  }

  private attachEventListeners(): void {
    const btnNew = this.container.querySelector('#btn-new-save');
    const btnImport = this.container.querySelector('#btn-import');
    const fileInput = this.container.querySelector('#import-file') as HTMLInputElement;

    btnNew?.addEventListener('click', () => this.handleNewSave());
    btnImport?.addEventListener('click', () => fileInput?.click());
    
    fileInput?.addEventListener('change', (e) => this.handleImport(e));
  }

  private attachSlotEventListeners(): void {
    // Load buttons
    this.container.querySelectorAll('.btn-load').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const slotId = (e.target as HTMLElement).dataset.id!;
        this.callbacks.onLoad?.(slotId);
      });
    });

    // Delete buttons
    this.container.querySelectorAll('.btn-delete').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        const slotId = (e.target as HTMLElement).dataset.id!;
        if (confirm('Delete this save? This cannot be undone.')) {
          await this.saveSystem.delete(slotId);
          this.callbacks.onDelete?.(slotId);
          await this.refresh();
        }
      });
    });

    // Export buttons
    this.container.querySelectorAll('.btn-export').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const slotId = (e.target as HTMLElement).dataset.id!;
        this.exportSave(slotId);
      });
    });
  }

  private async handleNewSave(): Promise<void> {
    const name = prompt('Enter save name:', \`Save \${new Date().toLocaleString()}\`);
    if (name) {
      await this.saveSystem.save(undefined, { customName: name });
      await this.refresh();
    }
  }

  private async handleImport(event: Event): Promise<void> {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
      const content = e.target?.result as string;
      try {
        const success = await this.saveSystem.import(content);
        if (success) {
          alert('Save imported successfully!');
          await this.refresh();
        } else {
          alert('Failed to import save file.');
        }
      } catch (err) {
        alert('Invalid save file format.');
      }
    };
    reader.readAsText(file);
  }

  private async exportSave(slotId: string): Promise<void> {
    const slot = await this.saveSystem.getSlot(slotId);
    if (!slot) return;

    const exportData = btoa(JSON.stringify(slot));
    const blob = new Blob([exportData], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = \`\${this.saveSystem.config.gameId}_\${slotId}.sav\`;
    a.click();
    
    URL.revokeObjectURL(url);
    this.callbacks.onExport?.(slotId);
  }

  show(): void {
    this.container.style.display = 'block';
    this.refresh();
  }

  hide(): void {
    this.container.style.display = 'none';
  }

  destroy(): void {
    this.container.innerHTML = '';
  }
}

// Quick Save/Load Hotkey Manager
class QuickSaveManager {
  private saveSystem: SaveSystem;
  private enabled: boolean = true;
  private lastSaveTime: number = 0;
  private cooldownMs: number = 1000;

  constructor(saveSystem: SaveSystem) {
    this.saveSystem = saveSystem;
    this.bindHotkeys();
  }

  private bindHotkeys(): void {
    document.addEventListener('keydown', (e) => {
      if (!this.enabled) return;

      // F5 - Quick Save
      if (e.key === 'F5') {
        e.preventDefault();
        this.quickSave();
      }
      // F9 - Quick Load
      else if (e.key === 'F9') {
        e.preventDefault();
        this.quickLoad();
      }
      // Ctrl+S - Save with dialog
      else if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        this.openSaveDialog();
      }
      // Ctrl+L - Load dialog
      else if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        this.openLoadDialog();
      }
    });
  }

  private async quickSave(): Promise<void> {
    const now = Date.now();
    if (now - this.lastSaveTime < this.cooldownMs) {
      this.showNotification('Save cooldown...', 'warning');
      return;
    }

    try {
      await this.saveSystem.quickSave();
      this.lastSaveTime = now;
      this.showNotification('Game saved!', 'success');
    } catch (err) {
      this.showNotification('Save failed!', 'error');
    }
  }

  private async quickLoad(): Promise<void> {
    try {
      await this.saveSystem.quickLoad();
      this.showNotification('Game loaded!', 'success');
    } catch (err) {
      this.showNotification('No quicksave found!', 'error');
    }
  }

  private openSaveDialog(): void {
    // Trigger custom event for game UI to handle
    document.dispatchEvent(new CustomEvent('savesystem:opensave'));
  }

  private openLoadDialog(): void {
    document.dispatchEvent(new CustomEvent('savesystem:openload'));
  }

  private showNotification(message: string, type: 'success' | 'error' | 'warning'): void {
    const notification = document.createElement('div');
    notification.className = \`save-notification \${type}\`;
    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => {
      notification.classList.add('fade-out');
      setTimeout(() => notification.remove(), 300);
    }, 2000);
  }

  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  destroy(): void {
    // Event listeners are automatically cleaned up when document is destroyed
  }
}

// Save Corruption Detection
class SaveIntegrityChecker {
  private saveSystem: SaveSystem;

  constructor(saveSystem: SaveSystem) {
    this.saveSystem = saveSystem;
  }

  async verifyAllSaves(): Promise<{ valid: string[]; corrupted: string[] }> {
    const saves = await this.saveSystem.listSaves();
    const result = { valid: [] as string[], corrupted: [] as string[] };

    for (const save of saves) {
      const isValid = await this.verifySave(save.id);
      if (isValid) {
        result.valid.push(save.id);
      } else {
        result.corrupted.push(save.id);
      }
    }

    return result;
  }

  async verifySave(slotId: string): Promise<boolean> {
    try {
      const slot = await this.saveSystem.getSlot(slotId);
      if (!slot) return false;

      // Verify checksum
      if (slot.data.checksum) {
        const expectedChecksum = this.calculateChecksum(slot.data.state);
        if (expectedChecksum !== slot.data.checksum) {
          console.error(\`[SaveIntegrity] Checksum mismatch for slot \${slotId}\`);
          return false;
        }
      }

      // Verify required fields exist
      const required = ['version', 'timestamp', 'gameId', 'state'];
      for (const field of required) {
        if (!(field in slot.data)) {
          console.error(\`[SaveIntegrity] Missing field: \${field}\`);
          return false;
        }
      }

      return true;
    } catch (error) {
      console.error('[SaveIntegrity] Verification error:', error);
      return false;
    }
  }

  private calculateChecksum(data: any): string {
    const str = JSON.stringify(data);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(16);
  }

  async repairSave(slotId: string): Promise<boolean> {
    // Attempt to repair corrupted save by extracting what we can
    try {
      const slot = await this.saveSystem.getSlot(slotId);
      if (!slot) return false;

      // Recalculate checksum with current data
      slot.data.checksum = this.calculateChecksum(slot.data.state);
      
      // Update the save
      await this.saveSystem.save(slotId, slot.metadata);
      
      console.log('[SaveIntegrity] Repaired save:', slotId);
      return true;
    } catch (error) {
      console.error('[SaveIntegrity] Repair failed:', error);
      return false;
    }
  }

  async deleteCorrupted(): Promise<number> {
    const { corrupted } = await this.verifyAllSaves();
    for (const slotId of corrupted) {
      await this.saveSystem.delete(slotId);
    }
    return corrupted.length;
  }
}

// CSS Styles for Save System UI
const SAVE_SYSTEM_STYLES = \`
.save-slot-selector {
  background: #1a1a2e;
  border-radius: 12px;
  padding: 20px;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
  color: #fff;
  font-family: system-ui, sans-serif;
}

.save-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid #333;
}

.save-header h3 {
  margin: 0;
  font-size: 1.5rem;
}

.save-storage-info {
  font-size: 0.85rem;
  color: #888;
}

.save-slots-grid {
  display: grid;
  gap: 12px;
  margin-bottom: 20px;
}

.save-slot {
  display: flex;
  align-items: center;
  background: #16213e;
  border-radius: 8px;
  padding: 12px;
  transition: background 0.2s;
  cursor: pointer;
}

.save-slot:hover {
  background: #1f2b47;
}

.save-thumbnail {
  width: 80px;
  height: 60px;
  border-radius: 6px;
  overflow: hidden;
  margin-right: 15px;
  background: #0f3460;
  display: flex;
  align-items: center;
  justify-content: center;
}

.save-thumbnail img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.save-placeholder {
  font-size: 1.5rem;
  font-weight: bold;
  color: #e94560;
}

.save-info {
  flex: 1;
}

.save-name {
  font-weight: 600;
  margin-bottom: 4px;
}

.save-details {
  font-size: 0.85rem;
  color: #888;
}

.save-details span {
  margin-right: 12px;
}

.save-meta {
  margin-top: 6px;
}

.badge {
  background: #e94560;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 0.75rem;
  margin-right: 8px;
}

.save-actions-dropdown {
  position: relative;
}

.btn-menu {
  background: none;
  border: none;
  color: #fff;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 5px 10px;
}

.dropdown-content {
  display: none;
  position: absolute;
  right: 0;
  top: 100%;
  background: #16213e;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 100;
}

.save-actions-dropdown:hover .dropdown-content {
  display: block;
}

.dropdown-content button {
  display: block;
  width: 100%;
  padding: 10px 20px;
  background: none;
  border: none;
  color: #fff;
  text-align: left;
  cursor: pointer;
  white-space: nowrap;
}

.dropdown-content button:hover {
  background: #1f2b47;
}

.save-actions {
  display: flex;
  gap: 10px;
  padding-top: 15px;
  border-top: 1px solid #333;
}

.btn-primary, .btn-secondary {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
}

.btn-primary {
  background: #e94560;
  color: #fff;
}

.btn-secondary {
  background: #0f3460;
  color: #fff;
}

.btn-close {
  margin-left: auto;
  background: none;
  border: none;
  color: #888;
  font-size: 1.5rem;
  cursor: pointer;
}

.no-saves {
  text-align: center;
  padding: 40px;
  color: #666;
}

/* Notifications */
.save-notification {
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 15px 25px;
  border-radius: 8px;
  color: #fff;
  font-weight: 500;
  z-index: 1000;
  animation: slideIn 0.3s ease;
}

.save-notification.success {
  background: #2ecc71;
}

.save-notification.error {
  background: #e74c3c;
}

.save-notification.warning {
  background: #f39c12;
}

.save-notification.fade-out {
  animation: fadeOut 0.3s ease forwards;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes fadeOut {
  to {
    opacity: 0;
    transform: translateY(20px);
  }
}

/* Loading indicator */
.save-loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.9);
  padding: 30px 50px;
  border-radius: 12px;
  color: #fff;
  z-index: 2000;
}

.save-loading::after {
  content: '';
  display: block;
  width: 40px;
  height: 40px;
  border: 3px solid #0f3460;
  border-top-color: #e94560;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 15px auto 0;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
\`;

// Inject styles into document
function injectSaveSystemStyles(): void {
  if (document.getElementById('save-system-styles')) return;
  
  const style = document.createElement('style');
  style.id = 'save-system-styles';
  style.textContent = SAVE_SYSTEM_STYLES;
  document.head.appendChild(style);
}
`;

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Complete save system code ready to inject into games
 */
export const SAVE_SYSTEM_CODE = `
${SAVE_SYSTEM_IMPLEMENTATION}

${SAVE_SYSTEM_UI_CODE}
`;

/**
 * Genre-specific save templates map
 */
export const GENRE_SAVE_TEMPLATES: Record<string, string> = {
  arena_shooter: ARENA_SHOOTER_SAVE_TEMPLATE,
  platformer: PLATFORMER_SAVE_TEMPLATE,
  rpg: RPG_SAVE_TEMPLATE,
  roguelike: ROGUELIKE_SAVE_TEMPLATE,
  strategy: STRATEGY_SAVE_TEMPLATE
};

/**
 * Generate a save system customized for a specific genre
 */
export function generateSaveSystemForGenre(
  genre: 'arena_shooter' | 'platformer' | 'rpg' | 'roguelike' | 'strategy',
  config: Partial<SaveSystemConfig>
): string {
  const template = GENRE_SAVE_TEMPLATES[genre] || GENRE_SAVE_TEMPLATES.arena_shooter;
  
  return `
/**
 * Auto-generated Save System for ${genre}
 * Generated by DREAM3DFORGE
 */

${SAVE_SYSTEM_IMPLEMENTATION}

${template}

${SAVE_SYSTEM_UI_CODE}

// Genre-specific save state factory
function createDefaultSaveState(): Record<string, any> {
  switch ('${genre}') {
    case 'arena_shooter':
      return createArenaShooterSaveState();
    case 'platformer':
      return createPlatformerSaveState();
    case 'rpg':
      return createRPGSaveState();
    case 'roguelike':
      return createRoguelikeSaveState();
    case 'strategy':
      return createStrategySaveState();
    default:
      return {};
  }
}

// Initialize save system with genre defaults
const saveSystemConfig: SaveSystemConfig = {
  gameId: '${config.gameId || 'dream3dforge_game'}',
  version: '${config.version || '1.0.0'}',
  maxSlots: ${config.maxSlots || 10},
  autoSaveInterval: ${config.autoSaveInterval || 0},
  compress: ${config.compress !== false},
  storageBackend: '${config.storageBackend || 'localStorage'}',
  storagePrefix: '${config.storagePrefix || 'dream3dforge_save_'}',
  enableChecksum: ${config.enableChecksum !== false},
  maxSaveSize: ${config.maxSaveSize || 5 * 1024 * 1024}
};

// Export for game use
window.SaveSystem = SaveSystem;
window.AutoSave = AutoSave;
window.SaveSlotSelector = SaveSlotSelector;
window.QuickSaveManager = QuickSaveManager;
window.SaveIntegrityChecker = SaveIntegrityChecker;
window.saveSystemConfig = saveSystemConfig;
window.createDefaultSaveState = createDefaultSaveState;
`;
}

/**
 * Generate TypeScript types/schema for a specific game blueprint
 */
export interface GameBlueprint {
  name: string;
  genre: string;
  version: string;
  stateFields: Array<{
    name: string;
    type: string;
    default: any;
    description?: string;
  }>;
  requiredFields?: string[];
  migrations?: Record<string, (data: any) => any>;
}

export function createSaveSchema(blueprint: GameBlueprint): SaveSchema {
  const fields: Record<string, any> = {};
  
  for (const field of blueprint.stateFields) {
    fields[field.name] = {
      type: field.type,
      default: field.default,
      description: field.description || `${field.name} field`
    };
  }

  return {
    version: blueprint.version,
    genre: blueprint.genre,
    required: blueprint.requiredFields || [],
    fields,
    migrations: blueprint.migrations || {}
  };
}

/**
 * Generate TypeScript interface from save schema
 */
export function generateTypeScriptInterface(schema: SaveSchema, interfaceName: string = 'GameSaveState'): string {
  const lines: string[] = [
    `/**`,
    ` * Auto-generated save state interface for ${schema.genre}`,
    ` * Version: ${schema.version}`,
    ` */`,
    `export interface ${interfaceName} {`,
    `  /** Save format version */`,
    `  version: string;`,
    `  /** Save timestamp */`,
    `  timestamp: number;`,
    ``,
    `  // Game State`,
  ];

  for (const [fieldName, fieldDef] of Object.entries(schema.fields)) {
    lines.push(`  /** ${fieldDef.description} */`);
    
    let tsType: string;
    switch (fieldDef.type) {
      case 'string':
        tsType = 'string';
        break;
      case 'number':
        tsType = 'number';
        break;
      case 'boolean':
        tsType = 'boolean';
        break;
      case 'array':
        tsType = 'any[]';
        break;
      case 'object':
        tsType = 'Record<string, any>';
        break;
      default:
        tsType = 'any';
    }
    
    // Handle nested fields (dot notation)
    const cleanFieldName = fieldName.includes('.') ? `'${fieldName}'` : fieldName;
    lines.push(`  ${cleanFieldName}${schema.required.includes(fieldName) ? '' : '?'}: ${tsType};`);
    lines.push('');
  }

  lines.push('}');
  
  // Add default state factory function
  lines.push('');
  lines.push(`export function createDefault${interfaceName}(): ${interfaceName} {`);
  lines.push('  return {');
  lines.push(`    version: '${schema.version}',`);
  lines.push('    timestamp: Date.now(),');
  
  for (const [fieldName, fieldDef] of Object.entries(schema.fields)) {
    if (fieldName.includes('.')) continue; // Skip nested fields for top level
    
    const defaultValue = JSON.stringify(fieldDef.default);
    lines.push(`    ${fieldName}: ${defaultValue},`);
  }
  
  lines.push('  };');
  lines.push('}');

  return lines.join('\n');
}

/**
 * Default save system configuration
 */
export const DEFAULT_SAVE_SYSTEM_CONFIG: SaveSystemConfig = {
  gameId: 'dream3dforge_game',
  version: '1.0.0',
  maxSlots: 10,
  autoSaveInterval: 0,
  compress: true,
  storageBackend: 'localStorage',
  storagePrefix: 'dream3dforge_save_',
  enableChecksum: true,
  maxSaveSize: 5 * 1024 * 1024
};

/**
 * Migration helper for updating save formats
 */
export function createMigration(
  fromVersion: string,
  toVersion: string,
  transform: (data: any) => any
): { from: string; to: string; transform: (data: any) => any } {
  return { from: fromVersion, to: toVersion, transform };
}

/**
 * Apply migrations to save data
 */
export function migrateSaveData(
  data: SaveData,
  migrations: Array<{ from: string; to: string; transform: (data: any) => any }>
): SaveData {
  let currentVersion = data.version;
  let migratedData = { ...data };

  for (const migration of migrations) {
    if (migration.from === currentVersion) {
      migratedData = {
        ...migratedData,
        state: migration.transform(migratedData.state),
        version: migration.to
      };
      currentVersion = migration.to;
    }
  }

  return migratedData;
}

// ============================================================================
// EXPORTS
// ============================================================================

export default {
  // Core save system
  SAVE_SYSTEM_CODE,
  
  // Genre templates
  ARENA_SHOOTER_SAVE_TEMPLATE,
  PLATFORMER_SAVE_TEMPLATE,
  RPG_SAVE_TEMPLATE,
  ROGUELIKE_SAVE_TEMPLATE,
  STRATEGY_SAVE_TEMPLATE,
  GENRE_SAVE_TEMPLATES,
  
  // Generation functions
  generateSaveSystemForGenre,
  createSaveSchema,
  generateTypeScriptInterface,
  
  // Utilities
  DEFAULT_SAVE_SYSTEM_CONFIG,
  createMigration,
  migrateSaveData
};
